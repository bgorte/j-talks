#+title: sandpile cellular automaton

* Intro
** sandpile demo
What you're looking at here is called a sandpile.
It's just a 2 dimensional array of natural numbers, and each number represents a number of grains of sand.
The numbers 0,1,2, and 3 make stable piles
But as soon as you put a number greater than 4 on the board, the pile in that cell topples,
sending one grain of sand to each of its four neighbors.

If you put a four next to the edge of the board, one of the grains just falls off the edge.
Same thing in the corners: two grains fall off.

If you have a four next to a three, then you wind up with a chain reaction.
It's a bit like dominoes.

And if you have any number greater than four, (say 2 to 16th),
then it will just keep pumping out four grains at each step,
until it runs down.

** segue to j
As you can see, you can start to get some really intricate mandala-like patterns.

* sandpaint
** orientation
my last video talked about how to use vmcc to draw 2d arrays (matrices) on the screen
nothing's changed for this big sandpile array
we're just drawing a matrix called ~sp~ on each tick.

Also note that we're passing in 'rgb' for our palette.
This means the numbers we pass in are 32bit rgba numbers like you'd see in html.
J lets you use any base you want.

** drawing the palette
the palette on the left isn't much different,
we're drawing a 1 by 16 matrix called pal

except we're also drawing some numbers
and we have this box to represent
the currently selected color.
that's stored in a variable called pen

** changing the pen color
mouse click handler:  =win_pal_mblup=
increment pen
which one we clicked
sysdata
=whichbox=
=pal_num=
=pal_rgb=
=pal_txt=

** drawing on the canvas
mapping colors to rgb
same mouse calculation, but now use amend

** the rules in j

** keyboard bindings


* cookbook
** generating arrays

So the promise was that we'd provide some way to control all this with code.
Here's what I had in mind:

#+begin_src j
NB. some nice arrays to look at.
im =: ? 10 10 $ 2            NB. random black/white pattern
im =: ? 100 100 $ 2          NB. higher resolution
im =: i. 10 10               NB. count to 100
im =: |: i. 10 10            NB. same thing, transposed
im =: i. 2 2                 NB. a simple 4-square
im =: j./~ i:10              NB. the complex plane, near the origin
im =: |j./~ i:10             NB. magnitudes from the center
im =: 10 10 $ 1              NB. pure white
im =: 1 (<5 5) } 11 11 $ 0   NB. one white pixel in the middle
im =: ~:/\^:(<@#) 8 # 1      NB. mysterious triangle??
#+end_src

These are just a bunch of lines I came up with.

** transformations
#+begin_src j
NB. operators on the current pattern:
im =: im * i.$im             NB. rainbowfy a black and white image
im =: 2 | im                 NB. reduce color to black and white (using mod 2)
im =: |: im                  NB. transpose
im =: |. im                  NB. flip top to bottom
im =: |."1 im                NB. flip left to right
im =: |: |. im               NB. rotate 90 degrees
im =: |. |: im               NB. rotate the other way
im =: -. im                  NB. flip the bits
im =: ,~ ,.~ im              NB. split into four copies
im =: (,|.) (,. |."1) im     NB. four copies, but mirrored across each axis
im =:  1 |. im               NB. rotate up (top row moves to bottom)
im =: _1 |. im               NB. rotate down
im =:  1 |."1 im             NB. rotate left
im =: _1 |."1 im             NB. rotate right
im =: }. im , 0              NB. shift up, pad with 0
im =: 0 , }: im              NB. shift down, pad with 0
im =: }."1 im ,. 0           NB. shift left, pad with 0
im =: 0 ,. }:"1 im           NB. shift right, pad with 0
#+end_src

you can experiment with running these lines interactively with ctrl-enter,
or ctrl-r which runs the line without advancing the cursor (so you can run it over and over again)

before i end, i should point out that while I was typing these, i'd occasionally
screw something up and set im to something that wasn't a 2d matrix.
This caused a modal error message to pop up on every frame, so that
and so every time I closed the message it popped right back up.

The only way to recover was to kill J, which was really annoying.
So to fix that, I added some trapping for this in the render verb:

#+begin_src j
render =: verb define
  if. 2 = #$ im            NB. only render if im is a 2d array
  do. vmcc im;'g0' end.    NB. (this avoids infinite error boxes)
)
#+end_src


* The Sandpile Paper

Sandpiles were introduced in a physics paper in 1987.

As far as I can tell, they were trying to model the idea that certain systems
tend to naturally settle into a critical point that's just barely stable,
where a slight disturbance triggers a huge change -
something like an avalanches and earthquakes.

So for their work, they generated big grids full of random big numbers,
letting everything settle, and then studied how far the cascade extended when
they then added a single extra gain of sand.

* Sandpile Math
Since then, sandpiles have caught the attention of mathematicians.
In fact, I first heard about them on a numberphile video
(which I've linked in the description)
that explains how for any size grid
(or even arbitrary connected graph)
there's a subset of sandpile configurations
that form a group under addition with settling.

So to show what that means, here's a little calculator.
Basically, you can this all-zero sandpile to any sandpile,
and it acts just like adding zero to an integer.

But you can never add any two other sandpiles together
to get this one, because you'd always leave some sand on the table.

But it turns out that for any size grid you can come up with,
there's always a subset of configurations for which you can define
a second zero, and for any sandpile in this subset, there's always
an inverse sandpile that brings it back to zero.

So this number in the middle is the group zero, and
according to this calculator, adding it to the grid of all
threes produces the grid of all threes.

If I understood everything correctly, then you can test whether
a particular configuration is in the group just by adding this
middle zero to it. If it comes out the same, then it ought
to have an inverse.

So for example, this grid of all threes has an inverse,
but any time you put two zeros next to each other,
you get something different. Same thing with any square of ones.
There's nothing you can add to this to get back to zero.

Well, okay, but how do we actually know this block of solid threes has an inverse?
I suspect there's an algorithm that comes up with it, and that people who have
studied this already know what it is. But I don't know what it is.

However, I do know what the inverse of this sandpile is, because I found it:

3 1 3 1 3
1 3 2 3 1
3 2 1 2 3
1 3 2 3 1
3 1 3 1 3

It's actually kind of an interesting puzzle to find a group item and then try to figure this out.


* Video Description and Links

Code for this episode:
https://github.com/tangentstorm/j-talks/tree/master/s1e1-sandpiles

Numberphile video on sandpiles with Dr Luis David Garcia-Puente:
https://www.youtube.com/watch?v=1MtEUErz7Gg

Professor David Perkinson has a textbook on sandpile math, as well as interactive software:
http://people.reed.edu/~davidp/

Original sandpile paper:
http://cqb.pku.edu.cn/tanglab/pdf/1987-63.pdf

Sandpile math paper, including the algorithm to generate the "zero":
https://hal.archives-ouvertes.fr/hal-00016378

WikiZero on sandpiles:
https://www.wikizero.com/en/Sandpile

Code golf challenge with sandpiles in various languages:
https://codegolf.stackexchange.com/questions/92251/build-a-sandpile

J Vocabulary:
https://code.jsoftware.com/wiki/NuVoc

Download J from:
https://code.jsoftware.com/wiki/Guides/Getting_Started
