#+title: sandpiles

* Sandpiles
# on stage: the 512 grain-in-the-center sandpile, copied to buffer.
# pen =: 1, grid off, timer off, focus in window!
What you're looking at here is called a sandpile.
# toggle grid
It's a two dimensional grid.
Each square contains zero or more grains of sand, indicated by the color.

# start drawing
If you have 0, 1, 2 or 3 grains, the pile is stable.
But as soon as you get to four grains, the sand topples over
sending one grain to each of the four neighboring cells.

# draw by the edge
If you have a four next to the edge of the board,
the same thing happens,
but one of the grains falls off the edge.
# .. and corner
Similarly, if you have a four in the corner, then two grains fall off.

# draw line of 3 at bottom
If you have a bunch of threes in a row,
and put a four next to it,
then when the four topples,
it adds a grain to the three,
giving you a new four
and then that one topples,
and you get a chain reaction.
# put mouse in center and press z to clear screen
And if you start with a bigger number number, (say 256),
then it will just keep pumping out four grains at each step.

# space a few times until zthe four neighbors pile up
So after four ticks, we have four piles of four, plus 240 grains left in the center.
All four of these topple,
and then the center keeps pumping out more.
# step until we get the diagonals
Now we have four cells with with one grain in them,
but each one has three neighbors that are about to topple.
So each of these ones will turn into fours.
# step
And each time the four surrounding the center topple,
the center sends out four,
but they simultaneously send four back
so for that particular step in the process,
the number in the center doesn't change.
# press 4

Anyway it goes on like that, and there's a little bit of back and forth
but before long the whole thing always winds down and comes to a stop.
# (fast forward)

The picture we started with was the same thing with 512 grains.

So as you can see, with just this one simple rule,
you start generating really intricate patterns rather quickly.
and it's kind of fun to just draw a pattern,
let it run, and see what comes out.

Depending on how you start you might get a nice pretty picture like this,
or if you just start pouring sand
# speed 3, then draw with pen 64
.. fast forward a bit...
# (fast forward)
you might just get a mess.

So that's sandpiles.

* sandpaint
** Building the window
#+begin_src j
spw_close =: verb define
  wd 'psel spw; pclose'
  wd 'timer 0'
)

NB. Recycle window if we run multiple times:
spw_close^:(wdisparent'spw')''

#+end_src

# fake intro

When I go to make something like this in J...


** reusing gridpad

#+begin_src j
cocurrent 'sandpaint'
coinsert 'sandpiles gridpad'

pen =: 2
img =: 25 25 $ 0

gpw_opt_title =: 'sandpaint'
gpw_opt_timer =: 500
gpw_opt_palv_wh =: 50 800
gpw_opt_imgv_wh =: 800 800
gpw_opt_colorpick =: 0

gpw_init''
wd 'pmove 900 100 0 0'
#+end_src

: coname'' -> base
: coname''
: copath coname''

We're actually going to make two apps. First this sandpaint program.
Later on, we're going to make a kind of sandpile calculator.


** sandpile colors

#+begin_src j
cocurrent 'sandpiles'

pal =: 0 1 2 3, 2^2+i.16                        NB. the actual values to draw

lo =: 16b00000f 16b3f3f9d 16b7878d8 16bacacff   NB. i.4 drawn as shades of blue
hi =: 16bff0000 + 16b001100 * i._16             NB. 4+i.204 are yellow..red
rgb =: lo,hi
#+end_src

So the 'lo' colors are just these blueish colors that I picked by hand,
The high colors are a gradient between yellow and red.

This '16b' indicates that the number is hexadecimal,
(kind of an unusual prefix, but you can specify any base you want)
then these two digits represent the red byte, (ff is 255, which is the highest value for a byte, so this is pure red),
the middle two represent green. 11 in hex is 16+1 or 17 so this is a really dark green.
Then here we're multiplying that green by the numbers 0 through 15, so it goes from 00 or black to ff or pure green.
And when you add the red, that gives you these shades of yellow and orange.

So pal is the palette, num is the number to actually put in the grid when we draw,
and then ... sandcolor is a verb that maps any number back to the palette.

It says for each number in the input, if it's less than or equal to four, leave it alone,
otherwise take the base 2 logarithm, round it down, and add two.
If that number is bigger than the length of the palette minus one
(meaning the last index, since they're numbered at zero),
then replace it with that number. (This symbol is max.)
Now we're left with an index, and we just take that item from the palette.

** color mapping
#+begin_src j
cocurrent 'sandpiles'

NB. map any non-negative integer to the palette
to_rgb =: rgb {~ (<:#rgb) <.(2+[:<.2^.])^:(>4:)"0

NB. map rgb colors back to the palette
shl =:  32 b. ~
to_pal =: (#pal) | rgb i. (1 shl 24)&|
#+end_src

** custom palette view

#+begin_src j
cocurrent 'sandpiles'

gpw_palv_paint =: verb define
  gpw_palv_paint0''                              NB. call original

  NB. draw text labels over the colors:
  glfont 'consolas 8'
  glpen 1 [ glbrush glrgb 0 0 0
  gltextcolor glrgb 255 255 255
  h =. {: palv_cellsize''
  for_n. pal do. i =. n_index
    if. i < 16 do. text =. ": n else. text =. '2^',":i-2 end.
    xx =. 25 - -: ww =.(8*#text)   NB. center text horizontally
    yy =. 15+h*i                   NB. vertically
    glrect xx, yy, (ww+1), 14
    gltextxy (2+xx),yy
    gltext text
  end.
)
#+end_src


Notice that up until now, we've never explicitly use a loop.
Working with arrays just gives us that implicitly.

When it came time to draw the labels on the palette,
I decided to use an actual loop.

You could certainly cram all this into one line without a loop,
but there's a lot going on, and it's not terribly interesting.

Basically, to center something, you take half the width of the drawing area
and subtract half the width of the thing you're drawing.

In the interest of time I'm not going to say more than that,
but if you want a better understanding of this,
the easiest way is to just download the code and experiment.

** time control
#+begin_src j
cocurrent 'sandpaint'

gpw_char =: verb define
  time_keys''
)

time_keys =: verb define
  select. {. sysdata
    case. ' ' do. gpw_timer [ wd'ptimer 0'          NB. space = single step
    case. '1' do. wd'ptimer 1000'                   NB. 1 = pretty slow
    case. '2' do. wd'ptimer 500'                    NB. ...
    case. '3' do. wd'ptimer 100'
    case. '4' do. wd'ptimer 50'
    case. '5' do. wd'ptimer 25'                     NB. ...
    case. '9' do. wd'ptimer 1'                      NB. 9 = fast as possible
    case. '0' do. wd'ptimer 0'                      NB. 0 = stop
  end.
)
#+end_src

Various number keys run the simulation at different speeds,
Zero stops the timer completely.
Space makes sure it's stopped and then takes a single step.

I like to animation into two steps: update and render.
And then render draws it. We're getting that for free from gridpad.
Update changes the scene - that's where we'll put our simulation rules.


** the rules in j
#+begin_src j
cocurrent 'sandpaint'

gpw_char =: verb define
  time_keys''
  select. {. sysdata
    case. '>' do. render img =: img > 3           NB. greater than 3
    case. 'w' do. render img =: }. img , 0        NB. move up
    case. 'a' do. render img =: }."1   img ,. 0   NB. move left
    case. 's' do. render img =: }: 0 , img        NB. move down
    case. 'd' do. render img =: }:"1 ] 0 ,. img   NB. move right
  end.
)
#+end_src

The first rule is that any cell with 3 grains or fewer is stable,
and we only need to address the values that are greater than 3.

The greater than operator has rank 0,
meaning it operates on each individual number in the input array,
and returns a result with the same shape as the input,
with a 1 in each cell where the left argument was greater,
and ther rest of the cells filled with zeros.

So these blue cells have at least four grains of sand.
We need to send one grain in each of the four directions.

One way to do that is to make four copies of this grid, shifted up, down, left, and right,
and add them all together.

We know how to add, so let's look at one way we could do shift.

Right curly dot is 'behead'. So all this does is append a row of zeros to the bottom of the grid,
and then chop off the first row. So all the values move up, and eventually some fall off the top.

In the other direction, right curly colon is 'curtail'.
It drops the last item of its input, so in this case, it drops the last row.
And prior to that, the zero comma appends a row of zeros to the top.
So this shifts the whole grid down.

Left and right work the exact same way, but you have to tell it to operate at rank 1,
meaning the rows of values rather than the list of rows.

Double quote is pronounced "rank" so this literally says behead at rank 1, curtail at rank 1.
The right bracket is just a passthrough function to separate the 1 from the 0 so they don't make an array.
(We could use parens the same way.)

Comma dot is called stitch. In this particular case it's the same thing as comma rank 1.
More precisely, it's comma rank negative 1, meaning one less than the rank of the inputs.
Since a grid is a rank two array, it has the effect of comma rank 1 and also looks a bit nicer.

** settle
#+begin_src j
cocurrent 'sandpiles'

settle =: monad define          NB. settle sandpiles with entries > 3
  gt =. y > 3
  up =. }.   gt ,  0            NB. shift in each of the 4 directions
  dn =. }:    0 ,  gt           NB. (filling in with 0 rather than wrapping)
  lf =. }."1 gt ,. 0
  rt =. }:"1  0 ,. gt
  cn =. _4 * gt                 NB. the 4 we subtract from the center
  y + up + dn + lf + rt + cn
)

update =: verb define
  img =: settle img
)
#+end_src

Okay, so now we can write settle.

So now when I press =2= to start the timer at two frames per second,
I can draw with sand and it topples in real time.

That's one way to write this in J.

If you're disappointed that this is too readable and easy to understand
and you were hoping for something more exotic to impress your friends
and terrify your enemies then I have just the thing for you.

** golfing
#+begin_src j
load'viewmat'
f=:_1 1|.!.0"0 _]
s=:(+[:(+/@(1&|:@f@|:,f)-4&*)3&<)^:_
viewmat s 4-s 50 50$4
#+end_src

Here is a complete standalone J program that fills a 50 by 50 grid with the
number four, runs the sandpile simulation until it stops, and outputs the results.

* The Sandpile Paper

Sandpiles were introduced in a physics paper in 1987.

#+begin_src j
cocurrent 'sandpaint'

copy =: img

gpw_char =: verb define
  time_keys''
  NB. -- original experiment --
  NB. Sandpiles were originally used as a simulation in the paper
  NB. "Self-organized criticality: an explanation of 1/f noise"
  NB. by Per Bak, Chao Tang and Kurt Wiesenfeld
  select. {. sysdata
    case. 'r' do. render img =: 4 + ? 100 100 $ 4  NB. r = big random grid
    case. 'f' do. render img =: settle^:_ img      NB. f = fast forward
    case. 'c' do. copy =: img                      NB. c = copy
    case. 'x' do. render 'img copy' =: copy;img    NB. x = swap
    case. '?' do. viewmat copy ~: img              NB. ? = show diff
  end.
)
#+end_src

As a layman, it was pretty hard for me to follow, but there's a link to in in the video description.

As far as I could tell, though, they were trying to model the idea that certain systems
tend to naturally settle into a critical point that's just barely stable,
where a slight disturbance triggers a huge change -
something like an avalanches and earthquakes.

So for their work, they generated big grids full of random big numbers,
letting everything settle, and then studied how far the cascade extended when
they set a single cell to four.

* Sandpile Math
Since then, sandpiles have caught the attention of mathematicians.
In fact, I first heard about them on a numberphile video
(which I've linked in the description)
that explains how for any size grid
(or even arbitrary connected graph)
there's a subset of sandpile configurations
that form a group under addition with settling.

* sandcalc - window

#+begin_src j
cocurrent 'sandcalc'
coinsert 'sandpiles gridpad'

gpw_opt_title =: 'sandcalc - sandpile calculator'
gpw_opt_timer =: 200
gpw_opt_statusbar =: 0
gpw_opt_colorpick =: 0
gpw_opt_menu =: ''

gpw_init_controls =: verb define
  wd'bin h'
  wd' minwh  50 200; cc palv isigraph;'
  wd' minwh 200 200; cc sp0v isidraw;'
  wd' cc "+" static;'
  wd' minwh 200 200; cc sp1v isidraw;'
  wd' cc "+" static;'
  wd' minwh 200 200; cc sp2v isidraw;'
  wd' cc "=" static;'
  wd' minwh 200 200; cc sp3v isidraw;'
  wd'bin z'
)

render =: ]  NB. because there's no 'imgv' control

gpw_init''

#+end_src

So to show what that means, here's a little calculator.
Basically, you can this all-zero sandpile to any sandpile,
and it acts just like adding zero to an integer.



* sandcalc - render

#+begin_src j
cocurrent 'sandcalc'

NxN =: 5 5

pal =: i.4                      NB. limit to stable piles
pen =: 0                        NB. color to draw with

sp0 =: NxN $ 0
sp1 =: NxN $ 3
sp2 =: NxN $ 0

(update =: verb define)''
  sp3 =: settle^:_ sp0 + sp1 + sp2
)

render =: verb define
  vmcc sp0;'sp0v'
  vmcc sp1;'sp1v'
  vmcc sp2;'sp2v'
  vmcc sp3;'sp3v'
)

#+end_src


* sandcalc - mouse

#+begin_src j
cocurrent 'sandcalc'

gpw_sp0v_mwheel =: gpw_sp1v_mwheel=: gpw_sp2v_mwheel=: gpw_palv_mwheel

NB. left click draws on the input
gpw_sp0v_mblup =: verb : 'sp0 =: sp0 img_draw whichbox 40'
gpw_sp1v_mblup =: verb : 'sp1 =: sp1 img_draw whichbox 40'
gpw_sp2v_mblup =: verb : 'sp2 =: sp2 img_draw whichbox 40'

NB. left drag does the same
gpw_sp0v_mmove =: verb : 'if. mbl _ do. gpw_sp0v_mblup _ end.'
gpw_sp1v_mmove =: verb : 'if. mbl _ do. gpw_sp1v_mblup _ end.'
gpw_sp2v_mmove =: verb : 'if. mbl _ do. gpw_sp2v_mblup _ end.'

NB. right click to copy the sum to an input
gpw_sp0v_mbrup =: verb : 'sp0 =: sp3'
gpw_sp1v_mbrup =: verb : 'sp1 =: sp3'
gpw_sp2v_mbrup =: verb : 'sp2 =: sp3'

NB. middle click to reset the input
gpw_sp0v_mbmup =: verb : 'sp0 =: NxN$0'
gpw_sp1v_mbmup =: verb : 'sp1 =: NxN$3'
gpw_sp2v_mbmup =: verb : 'sp2 =: ZSP'

ZSP =: NxN $ 0 NB. the trivial zero
#+end_src


* the zero sandpile : construction

Make a 5x5 sandpile of all 4s

settle it.

clean up border

reverse it


* the zero sandpile in j

#+begin_src j
cocurrent 'sandcalc'

stl =: settle^:_
ZSP =: stl (4 - stl) NxN $ 4
sp2 =: ZSP

#+end_src


But you can never add any two other sandpiles together
to get this one, because you'd always leave some sand on the table.

But it turns out that for any size grid you can come up with,
there's always a subset of configurations for which you can define
a second zero, and for any sandpile in this subset, there's always
an inverse sandpile that brings it back to zero.

So this number in the middle is the group zero, and
according to this calculator, adding it to the grid of all
threes produces the grid of all threes.

If I understood everything correctly, then you can test whether
a particular configuration is in the group just by adding this
middle zero to it. If it comes out the same, then it ought
to have an inverse.

So for example, this grid of all threes has an inverse,
but any time you put two zeros next to each other,
you get something different. Same thing with any square of ones.
There's nothing you can add to this to get back to zero.

Well, okay, but how do we actually know this block of solid threes has an inverse?
I suspect there's an algorithm that comes up with it, and that people who have
studied this already know what it is. But I don't know what it is.

However, I do know what the inverse of this sandpile is, because I found it:

* inverse of all threes
#+begin_src j
cocurrent 'sandcalc'

sp0 =: ".;._2 noun define
  3 1 3 1 3
  1 3 2 3 1
  3 2 1 2 3
  1 3 2 3 1
  3 1 3 1 3
)

wd'psel gpw; ptop'
#+end_src

It's actually kind of an interesting puzzle to find a group item and then try to figure out the inverse.


* Video Description and Links

Code for this episode:
https://github.com/tangentstorm/j-talks/tree/master/s1e1-sandpiles

Numberphile video on sandpiles with Dr Luis David Garcia-Puente:
https://www.youtube.com/watch?v=1MtEUErz7Gg

Professor David Perkinson has a textbook on sandpile math, as well as interactive software:
http://people.reed.edu/~davidp/

Original sandpile paper:
http://cqb.pku.edu.cn/tanglab/pdf/1987-63.pdf

Sandpile math paper, including the algorithm to generate the "zero":
https://hal.archives-ouvertes.fr/hal-00016378

WikiZero on sandpiles:
https://www.wikizero.com/en/Sandpile

Code golf challenge with sandpiles in various languages:
https://codegolf.stackexchange.com/questions/92251/build-a-sandpile

J Vocabulary:
https://code.jsoftware.com/wiki/NuVoc

Download J from:
https://code.jsoftware.com/wiki/Guides/Getting_Started
