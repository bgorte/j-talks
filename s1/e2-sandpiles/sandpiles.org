#+title: sandpile cellular automaton

* Intro (sandpile demo)
# on stage: the 512 grain-in-the-center sandpile, copied to buffer.
# pen =: 1, grid off, timer off, focus in window!
What you're looking at here is called a sandpile.
# toggle grid
It's a two dimensional grid.
Each square contains zero or more grains of sand, indicated by the color.

# start drawing
If you have 0, 1, 2 or 3 grains, the pile is stable.
But as soon as you get to four grains, the sand topples over
sending one grain to each of the four neighboring cells.

# draw by the edge
If you have a four next to the edge of the board,
the same thing happens,
but one of the grains falls off the edge.
# .. and corner
Similarly, if you have a four in the corner, then two grains fall off.

# draw line of 3 at bottom
If you have a bunch threes in a row,
and put a four next to it,
then when the four topples,
it adds a grain to the three,
giving you a new four
and then that one topples,
and you get a chain reaction.
# put mouse in center and press z to clear screen
And if you start with a bigger number number, (say 256),
then it will just keep pumping out four grains at each step.

# space a few times until zthe four neighbors pile up
So after four ticks, we have four piles of four, plus 240 grains left in the center.
All four of these topple,
and then the center keeps pumping out more.
# step until we get the diagonals
Now we have four cells with with one grain in them,
but each one has three neighbors that are about to topple.
So each of these ones will turn into fours.
# step
And each time the four surrounding the center topple,
the center sends out four,
but they simultaneously send four back
so for that particular step in the process,
the number in the center doesn't change.
# press 4

Anyway it goes on like that, and there's a little bit of back and forth
but before long the whole thing always winds down and comes to a stop.
# (fast forward)

The picture we started with was the same thing with 512 grains.

So as you can see, with just this one simple rule,
you start generating really intricate patterns rather quickly.
and it's kind of fun to just draw a pattern,
let it run, and see what comes out.

Depending on how you start you might get a nice pretty picture like this,
or if you just start pouring sand
# speed 3, then draw with pen 64
.. fast forward a bit...
# (fast forward)
you might just get a mess.

So that's sandpiles.

So, I've got a few more demos at the end of the video.
But mostly I want to talk about how to build
applications like this in J. Including both
the mouse and keyboard parts and also just how to
approach coding the rules for this kind of simulation.


* sandpaint
** TODO Recap
(need to recap up to gridpad video now)

** The colors

#+begin_src j
lo =: 16b00000f 16b3f3f9d 16b7878d8 16bacacff   NB. i.4 drawn as shades of blue
hi =: 16bff0000 + 16b001100 * i._16             NB. 4+i.204 are yellow..red

pal =: lo,hi
num =: 0 1 2 3, 2^2+i.16                        NB. the actual values to draw
#+end_src

So the first four colors are just these blueish colors that I picked by hand,
and this formula calculates the gradient between yellow and red.
This '16b' indicates that the number is hexadecimal,
(kind of an unusual prefix, but you can specify any base you want)
then these two digits represent the red byte, (ff is 255, which is the highest value for a byte, so this is pure red),
the middle two represent green. 11 in hex is 16+1 or 17 so this is a really dark green.
Then here we're multiplying that green by the numbers 0 through 15, so it goes from 00 or black to ff or pure green.
And when you add the red, that gives you these shades of yellow and orange.


So pal is the palette, num is the number to actually put in the grid when we draw,
and then ... sandcolor is a verb that maps any number back to the palette.

#+begin_src j
NB. map any non-negative integer to the palette
sandcolor =: pal {~ (<:#pal) <.(2+[:<.2^.])^:(>4:)"0
#+end_src

It says for each number in the input, if it's less than or equal to four, leave it alone,
otherwise take the base 2 logarithm, round it down, and add two.
If that number is bigger than the length of the palette minus one
(meaning the last index, since they're numbered at zero),
then replace it with that number. (This symbol is max.)
Now we're left with an index, and we just take that item from the palette.

So if we apply this function the values in num, we should see our palette.

: hfd sandcolor num

** drawing the palette

Notice that up until now, we've never explicitly use a loop.
Working with arrays just gives us that implicitly.

When it came time to draw the labels on the palette,
I decided to use an actual loop.

You could certainly cram all this into one line without a loop,
but there's a lot going on, and it's not terribly interesting.

Basically, to center something, you take half the width of the drawing area
and subtract half the width of the thing you're drawing.

In the interest of time I'm not going to say more than that,
but if you want a better understanding of this,
the easiest way is to just download the code and experiment.

** keyboard bindings

One more thing before we move onto the simulation part. Let's add some key bindings.

It's just another event handler:

#+begin_src j
spw_pal_char =: spw_sp_char =: verb define
  smoutput sysdata
)
#+end_src

Except now sysdata contains the character you type on the keyboard.
It's actually a string but with some special handling for arrow keys.
There's also a separate event for function keys and control key combinations
because those are global to the whole window, and these are specific to a child control.
But this is good enough for now. So let's grab the first character and make it do things.

#+begin_src j
 select. {. sysdata
   case. 'z' do. render grid =: ($grid)$0          NB. z = all zero
   case. 'r' do. render grid =:?($grid)$4          NB. r = random
   case. 'g' do. render showgrid =: -. showgrid    NB. g = toggle grid lines
   case. '1' do. wd'timer 1000'                    NB. 1 = pretty slow
   case. '2' do. wd'timer 500'                     NB. ...
   case. '3' do. wd'timer 100'
   case. '4' do. wd'timer 50'
   case. '5' do. wd'timer 25'                      NB. ...
   case. '9' do. wd'timer 1'                       NB. 9 = fast as possible
   case. '0' do. wd'timer 0'                       NB. 0 = stop
   case. ' ' do. step [ wd'timer 0'                NB. space = single step
 end.
#+end_src

As it says, z sets every cell to zero, r makes every cell a random int between 0 and 3.
g toggles the grid display. (This -. symbol means 'not', or 1 minus.)
Various number keys run the simulation at different speeds,
Zero stops the timer completely.
Space makes sure it's stopped and then takes a single step.

If you recall, step is just the composition of render and update.
We've already looked at render, so now we need to implement update.

All update needs to do is take one step in the sandpile simulation.
I'm going to call that operation 'settle':

#+begin_src j
update =: verb define
  grid =: settle grid
)

settle =: ] NB. TODO
#+end_src

Before I fill this in, let's add a few more keyboard shortcuts so we can look at each step in isolation:

** the rules in j

The first rule is that any cell with 3 grains or fewer is stable,
and we only need to address the values that are greater than 3.

#+begin_src j
   case. '>' do. render grid =: grid > 3           NB. > = greater than 3
#+end_src

The greater than operator has rank 0,
meaning it operates on each individual number in the input array,
and returns a result with the same shape as the input,
with a 1 in each cell where the left argument was greater,
and ther rest of the cells filled with zeros.

So if we press r to make a random array of numbers less than four,
sprinkle in some big numbers
and then press the button
we reduce the whole thing to ones and zeros.

So these blue cells have at least four grains of sand.
We need to send one grain in each of the four directions.

One way to do that is to make four copies of this grid, shifted up, down, left, and right,
and add them all together.

We know how to add, so let's look at one way we could do shift.

#+begin_src j
   case. 'w' do. render grid =: }. grid , 0     NB. w = move up
#+end_src

Right curly dot is 'behead'. So all this does is append a row of zeros to the bottom of the grid,
and then chop off the first row. So all the values move up, and eventually some fall off the top.

#+begin_src j
   case. 's' do. render grid =: }: 0 , grid     NB. s = move down
#+end_src

In the other direction, right curly colon is 'curtail'.
It drops the last item of its input, so in this case, it drops the last row.
And prior to that, the zero comma appends a row of zeros to the top.
So this shifts the whole grid down.

#+begin_src j
   case. 'a' do. render grid =: }."1   grid ,. 0     NB. a = move left
   case. 'd' do. render grid =: }:"1 ] 0 ,. grid     NB. d = move right
#+end_src

Left and right work the exact same way, but you have to tell it to operate at rank 1,
meaning the rows of values rather than the list of rows.

Double quote is pronounced "rank" so this literally says behead at rank 1, curtail at rank 1.
The right bracket is just a passthrough function to separate the 1 from the 0 so they don't make an array.
(We could use parens the same way.)

Comma dot is called stitch. In this particular case it's the same thing as comma rank 1.
More precisely, it's comma rank negative 1, meaning one less than the rank of the inputs.
Since a grid is a rank two array, it has the effect of comma rank 1 and also looks a bit nicer.

** settle

Okay, so now we can write settle.

#+begin_src j
settle =: monad define          NB. settle sandpiles with entries > 3
  gt =. y > 3
  up =. }.   gt ,  0            NB. shift in each of the 4 directions
  dn =. }:    0 ,  gt           NB. (filling in with 0 rather than wrapping)
  lf =. }."1 gt ,. 0
  rt =. }:"1  0 ,. gt
  cn =. _4 * gt                 NB. the 4 we subtract from the center
  y + up + dn + lf + rt + cn
)
#+end_src

So now when I press =2= to start the timer at two frames per second,
I can draw with sand and it topples in real time.

** golfing

That's one way to write this in J.

If you're disappointed that this is too readable and easy to understand
and you were hoping for something more exotic to impress your friends
and terrify your enemies
then I have just the thing for you.

Here is a complete standalone J program that fills a 50 by 50 grid with the
number four, runs the sandpile simulation until it stops, and outputs the results.

* The Sandpile Paper

Sandpiles were introduced in a physics paper in 1987.

#+begin_src j
   NB. -- original experiment --
   NB. Sandpiles were originally used as a simulation in the paper
   NB. "Self-organized criticality: an explanation of 1/f noise"
   NB. by Per Bak, Chao Tang and Kurt Wiesenfeld
   case. 'R' do. render grid =: 4 + ? 100 100 $ 4  NB. R = 'big' random
   case. 'f' do. render grid =: settle^:_ grid     NB. f = fast forward
   case. 'c' do. copy =: grid                      NB. c = copy
   case. 'x' do. render 'grid copy' =: copy;grid   NB. x = swap
   case. '?' do. viewmat copy ~: grid              qNB. ? = show diff
#+end_src

As a layman, it was pretty hard for me to follow, but there's a link to in in the video description.

As far as I could tell, though, they were trying to model the idea that certain systems
tend to naturally settle into a critical point that's just barely stable,
where a slight disturbance triggers a huge change -
something like an avalanches and earthquakes.

So for their work, they generated big grids full of random big numbers,
letting everything settle, and then studied how far the cascade extended when
they set a single cell to four.

* Sandpile Math
Since then, sandpiles have caught the attention of mathematicians.
In fact, I first heard about them on a numberphile video
(which I've linked in the description)
that explains how for any size grid
(or even arbitrary connected graph)
there's a subset of sandpile configurations
that form a group under addition with settling.

So to show what that means, here's a little calculator.
Basically, you can this all-zero sandpile to any sandpile,
and it acts just like adding zero to an integer.

But you can never add any two other sandpiles together
to get this one, because you'd always leave some sand on the table.

But it turns out that for any size grid you can come up with,
there's always a subset of configurations for which you can define
a second zero, and for any sandpile in this subset, there's always
an inverse sandpile that brings it back to zero.

So this number in the middle is the group zero, and
according to this calculator, adding it to the grid of all
threes produces the grid of all threes.

If I understood everything correctly, then you can test whether
a particular configuration is in the group just by adding this
middle zero to it. If it comes out the same, then it ought
to have an inverse.

So for example, this grid of all threes has an inverse,
but any time you put two zeros next to each other,
you get something different. Same thing with any square of ones.
There's nothing you can add to this to get back to zero.

Well, okay, but how do we actually know this block of solid threes has an inverse?
I suspect there's an algorithm that comes up with it, and that people who have
studied this already know what it is. But I don't know what it is.

However, I do know what the inverse of this sandpile is, because I found it:

3 1 3 1 3
1 3 2 3 1
3 2 1 2 3
1 3 2 3 1
3 1 3 1 3

It's actually kind of an interesting puzzle to find a group item and then try to figure out the inverse.


* Video Description and Links

Code for this episode:
https://github.com/tangentstorm/j-talks/tree/master/s1e1-sandpiles

Numberphile video on sandpiles with Dr Luis David Garcia-Puente:
https://www.youtube.com/watch?v=1MtEUErz7Gg

Professor David Perkinson has a textbook on sandpile math, as well as interactive software:
http://people.reed.edu/~davidp/

Original sandpile paper:
http://cqb.pku.edu.cn/tanglab/pdf/1987-63.pdf

Sandpile math paper, including the algorithm to generate the "zero":
https://hal.archives-ouvertes.fr/hal-00016378

WikiZero on sandpiles:
https://www.wikizero.com/en/Sandpile

Code golf challenge with sandpiles in various languages:
https://codegolf.stackexchange.com/questions/92251/build-a-sandpile

J Vocabulary:
https://code.jsoftware.com/wiki/NuVoc

Download J from:
https://code.jsoftware.com/wiki/Guides/Getting_Started
