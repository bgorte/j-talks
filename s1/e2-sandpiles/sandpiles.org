#+title: sandpiles

* TODO [0/0] tasks
- make sandpaint 32x32
- adjust the size and width and centering of the palette for sandpaint.
- segue to sandpile paper
- key to position terminal above the editor and size the editor
- plot sizing
- double check normalize verb in sandpaper
- come with a good 5-10 second summary of 1/f noise
- tie into windows dll to manipulate windows from j
- see if i can disable shaking a window to clear the other windows
- cool script for the end

* TODO setup                                                    :stage:
#+begin_src j
erase_sandpaint_ nl_sandpaint_''
erase_sandpiles_ nl_sandpiles_''
erase_sandcalc_ nl_sandcalc_''
erase_gridpad_ nl_gridpad_''
cocurrent'base'

NB. have inheritance image positioned and minimized.
#+end_src

* TODO 0. demo
# on stage: the 512 grain-in-the-center sandpile, copied to buffer.
# pen =: 1, grid off, timer off, focus in window!
What you're looking at here is called a sandpile.
# toggle grid
It's a two dimensional grid.
Each square contains zero or more grains of sand, indicated by the color.

# start drawing
If you have 0, 1, 2 or 3 grains, the pile is stable.
But as soon as you get to four grains, the sand topples over
sending one grain to each of the four neighboring cells.

# draw by the edge
If you have a four next to the edge of the board,
the same thing happens,
but one of the grains falls off the edge.
# .. and corner
Similarly, if you have a four in the corner, then two grains fall off.

# draw line of 3 at bottom
If you have a bunch of threes in a row,
and put a four next to it,
then when the four topples,
it adds a grain to the three,
giving you a new four
and then that one topples,
and you get a chain reaction.
# put mouse in center and press z to clear screen
And if you start with a bigger number number, (say 256),
then it will just keep pumping out four grains at each step.

# space a few times until zthe four neighbors pile up
So after four ticks, we have four piles of four, plus 240 grains left in the center.
All four of these topple,
and then the center keeps pumping out more.
# step until we get the diagonals
Now we have four cells with with one grain in them,
but each one has three neighbors that are about to topple.
So each of these ones will turn into fours.
# step
And each time the four surrounding the center topple,
the center sends out four,
but they simultaneously send four back
so for that particular step in the process,
the number in the center doesn't change.
# press 4

Anyway it goes on like that, and there's a little bit of back and forth
but before long the whole thing always winds down and comes to a stop.
# (fast forward)

The picture we started with was the same thing with 512 grains.

So as you can see, with just this one simple rule,
you start generating really intricate patterns rather quickly.
and it's kind of fun to just draw a pattern,
let it run, and see what comes out.

Depending on how you start you might get a nice pretty picture like this,
or if you just start pouring sand
# speed 3, then draw with pen 64
.. fast forward a bit...
# (fast forward)
you might just get a mess.

So that's sandpiles.

* TODO 1. sandpiles
#+begin_src j

NB. (title card: sandpiles)

#+end_src
** TODO overview
#+begin_src j
Note 'topics'
  - sandpaint
  - original paper
  - sandcalc
)
#+end_src

Now that you know the basics of sandpiles,
I'm going to show you how to build a simulation
like this in the J programming language.

We're going to build the drawing tool you just saw.

Then we're going to demonstrate the original
experiment where sandpiles were first invented.

Finally, we're going to turn all this into
a cross between a calculator and a puzzle game
that shows off some of the mathematical
properties of sandpiles.

...

So let's get started.

** TODO gridpad
#+begin_src j
load '~JTalks/s1/e2-sandpiles/gridpad.ijs'

echo names_gridpad_''

gpw_init_gridpad_''
#+end_src

cover code review

# transition slide: sandpaint
# start with this already running.

I already made a basic drawing program in my last video,
so I'm not going to repeat all that here.

If you haven't seen it, don't worry. The important idea
is that this window is just editing a 2 dimensional array,
and there's a timer that repaints it every few milliseconds.

If you did see the last video, I've renamed a few things
and refactored it a bit, but the basic ideas are all the same.

Now, to make it reusable, I extracted variables for a bunch of
configuration options, indicated by this gpo prefix. It's
short for gridpad option.

Then gpw indicates an event handler or lifecycle method
on the window.

And the others are either internals or things you're
pretty much always going to override.

So starting from what we have here,
I'm going to show you every line of code as I go along,
but in this video, I'm not going to stop and explain
exactly what every symbol means.

J is a really concise and expressive language, and I could
easily spend fifteen minutes explaining each line of code.

What I really want to get across in this video is just
the flow of ideas - how to think with the building
blocks J gives us.

Now if you're actually interested in learning the notation,
you should still watch this video first for context, but I'm
also going to post a second code review video,
where I walk through everything I've done here line by line
and really explain what each symbol does.

So if you want to see that, or you just want to see more
videos like this, now's a great time to hit the subscribe button.

Meanwhile, on with the show.

** TODO inheritance
#+begin_src j
cocurrent 'sandpiles'
coinsert 'gridpad'

cocurrent 'sandpaint'
coinsert 'sandpiles'

cocurrent 'sandcalc'
coinsert 'sandpiles'
#+end_src

These lines set up our inheritance hierarchy.

And usually they'd be scattered across different files.

The word cocurrent switches the current locale, which is J's term for a namespace,
creating it if it doesn't already exist.

And coinsert adds an entry to the lookup path,
which is what enables the inheritance mechanism.

All of our sandpile-specific logic will go into the sandpiles application.

And these other two applications are going to override and modify that in different ways.

** setup for next slide                                        :stage:
#+begin_src j
NB. hide terminal, run next window, bring to lower left quadrant.

#+end_src
** TODO sandpiles window
#+begin_src j
cocurrent'sandpiles'

gpo_title =: 'sandpiles'
gpo_colorpick =: 0
gpo_palv_wh =: 50 480

gpw_init''
#+end_src

So we'll start by overriding the title,
turn off the ability to pick new colors,
and make the palette view a bit wider
so there's room to draw some labels.

Then =gpw_init= fires up our modified gridpad.

** TODO sandpile colors
#+begin_src j
cocurrent 'sandpiles'

pal =: 0 1 2 3, 2^2+i.16                        NB. the actual values to draw
pen =: 1

lo =: 16b00000f 16b3f3f9d 16b7878d8 16bacacff   NB. i.4 drawn as shades of blue
hi =: 16bff0000 + 16b001100 * i._16             NB. 4+i.204 are yellow..red
rgb =: lo,hi

NB. map any number of grains to rgb
to_rgb =: rgb {~ (<:#pal) <. pal I. ]

NB. map rgb colors back to the palette
shl =: 32 b. ~
to_pal =: pal {~ (#rgb) | rgb i. (1 shl 24)&|

#+end_src

This code sets up our colors.
: (run)
The palette isn't hooked up to the timer
so we click the window to make it repaint.

One thing I added since the last video
were some hooks in for mapping between
the palette and rgb.

So now the palette is just the raw numbers zero through four
and then 8, 16, 32, and so on.

The verb =to_rgb= maps numbers in the image
to one of those intervals.
For example, 11 falls between 8 and 16,
so we color it like an 8.

This part in the middle says that if the number is out of range, just
map it to the last entry.

Also, if you open a PNG file in here, =to_pal=
strips out the alpha channel then maps these exact colors
to those exact numbers.

And here, the part in the middle says map any other color to zero.

But for now, we have our colors, so let's move on.

** TODO palette labels
#+begin_src j
cocurrent 'sandpiles'

gpw_palv_paint =: verb define
  gpw_palv_paint0''                              NB. call original

  NB. draw text labels over the colors:
  glfont 'consolas 8'
  glpen 1 [ glbrush glrgb 0 0 0
  gltextcolor glrgb 255 255 255
  h =. {: palv_cellsize''
  for_n. pal do. i =. n_index
    if. i < 16 do. text =. ": n else. text =. '2^',":i-2 end.
    xx =. 25 - -: ww =.(8*#text)   NB. center text horizontally
    yy =. <.h*i+0.275              NB. vertically
    glrect xx, yy, (ww+1), 14
    gltextxy (2+xx),yy
    gltext text
  end.
)
#+end_src

This is the paint event handler for the palette view.

: run and click

It calls the original handler from gridpad,
and then does an expliict loop through the palette to draw labels.

This is just minor cosmetic stuff, so if you want details, see the code review.

** TODO approaching the rules
#+begin_src j
cocurrent 'sandpiles'

gpw_char =: verb define  NB. key handler for imgv and palv controls.
  select. {. sysdata     NB. 'wasd' is ',aoe' on a dvorak keyboard :)
    case. '>' do. render img =: img > 3           NB. greater than 3
    case. ',' do. render img =: }. img , 0        NB. move up
    case. 'o' do. render img =: }: 0 , img        NB. move down
    case. 'a' do. render img =: }."1   img ,. 0   NB. move left
    case. 'e' do. render img =: }:"1  ]0 ,. img   NB. move right
  end.
)
#+end_src

So this is the keyboard handler. Let's define
some temporary keyboard shortcuts
to help us visualize the steps of the sandpile simulation.

Let's say we have some arbitrary sandpile

: open face

 and we want to decide
what's going to happen next.

The first rule is that any cell with 3 grains or fewer is stable,
so we only care about values greater than 3. So in this image,
all we want are the eyes and mouth and these little antennas
on top, and this border, which is there so you can see things
falling off the edge.

To isolate those, we can just compare the whole image to the number three.
The basic comparision operators all have rank 0, so they compare
each individual item, leaving us with an array of zeros and ones.

We could also say that we now have one grain of sand for each cell that's going to topple.
So now we just need to make a copy of this array shifted over one cell in each of the four directions.

That's what these other four lines do.

# show it

So remember our image is a list of rows of numbers.
So to shift the image up, we add a row of zeros at the bottom and then chop off the first row.
To shift down, we add a row of zeros to the start and cut off the bottom row.

Left and right work the same way, but they operate at the row level, or rank 1.
Appending at the next to top level is a builtin - that's comma dot, or stitch.
For behead and curtail, we just expliictly say rank 1, and the right identity
function here is just acting as a separator so the one and zero don't turn into an array.

We lost some sand along the way here because it fell off the edge. We need to
make a fresh copy before we nudge in each direction so we don't lose it, but
then all way have to do is take our four shifted copies and add them to the
original image, and then subtract four to remove them from the center.

** TODO settle
#+begin_src j
cocurrent 'sandpiles'

settle =: monad define          NB. settle sandpiles with entries > 3
  gt =. y > 3
  up =. }.   gt ,  0            NB. shift in each of the 4 directions
  dn =. }:    0 ,  gt           NB. (filling in with 0 rather than wrapping)
  lf =. }."1 gt ,. 0
  rt =. }:"1 ]0 ,. gt
  cn =. _4 * gt                 NB. the 4 we subtract from the center
  y + up + dn + lf + rt + cn
)

update =: verb define
  img =: settle img
)
#+end_src

Okay, so now we can write settle.

It's exactly what we just said, where gt is the fresh copy we start with each time,
and shift up down left and right. Then cn just multiplies by negative four. And the
result is all of that added back to the original image.

The update method is gridpad's hook to perform our animation, so once I run this,
I can draw with sand and it topples in real time.

Okay, so that's the beginner way to write this in J.

If you're disappointed that this is too readable and easy to understand
and you were hoping for something more exotic to impress your friends
and terrify your enemies then I have just the thing for you.

* TODO 1a. code golf
#+begin_src j
NB. (title card: code golf)
#+end_src
** TODO golfed sandpile sim
#+begin_src j
load'viewmat'

f=:_1 1|.!.0"0 _]
s=:(++/@(_4&*,f,f&.(|:"2))@(3&<))^:_

viewmat s 50 50$4
#+end_src

Here is a complete standalone J program
that fills a 50 by 50 grid with the number four,
runs the sandpile simulation until it stops,
and outputs the results.

** TODO golfed sandpile sim (with color)
#+begin_src j
load'viewmat'

f=:_1 1|.!.0"0 _]
s=:(++/@(_4&*,f,f&.(|:"2))@(3&<))^:_

NB. was:     viewmat s 50 50$4
'rgb' viewmat to_rgb s 50 50$4
#+end_src

If you want our color scheme you can borrow =to_rgb=.

# run it

So if you want to know what that means,
stay tuned for the code review.

Btw, the title here says "golfed"...
Code golf is a game programmers play where you try to
express an idea in as few characters as possible, and
J is a favorite language among code golfers.

Actually, this is the shortest version of the sandpile
simulation I could think of, but it's also pretty much
the natural way to write it in J - at least for me.

The only thing I did to golf it was to remove
all the extra spaces If you're realy brave, maybe
you can come up with I encourage you to download
J and try it yourself.

Meanwhile back to our program.

* TODO 2. sandpaint
#+begin_src j

NB. (title card: sandpaint)

#+end_src
** TODO sandpaint window
#+begin_src j
cocurrent 'sandpaint'

img =: 25 25 $ 0

gpo_title =: 'sandpaint'
gpo_timer =: 500
gpo_palv_wh =: 50 800
gpo_imgv_wh =: 800 800

gpw_init''

NB. move it on-camera:
wd 'pmove 900 100 0 0'
#+end_src

So here's the main code for sandpaint.
It just sets the window title and timer speed,
changes the size of the controls,
and turns off the color picker.

** TODO time control
#+begin_src j
cocurrent 'sandpaint'

gpw_char =: verb define
  time_keys''
)

time_keys =: verb define
  select. {. sysdata
    case. ' ' do. gpw_timer [ wd'ptimer 0'          NB. space = single step
    case. '1' do. wd'ptimer 1000'                   NB. 1 = pretty slow
    case. '2' do. wd'ptimer 500'                    NB. ...
    case. '3' do. wd'ptimer 100'
    case. '4' do. wd'ptimer 50'
    case. '5' do. wd'ptimer 25'                     NB. ...
    case. '9' do. wd'ptimer 1'                      NB. 9 = fast as possible
    case. '0' do. wd'ptimer 0'                      NB. 0 = stop
  end.
)
#+end_src

Okay, here's the real keyboard handler.

Last video, I used the window driver's timer command.
It turns out if you use ptimer instead, you can set a timer
just for one window, and it sends you an event on each tick.

The event handler name is windowname underscore timer so
setting ptimer 0 and then calling =gpw_timer= lets us fake
a timer event every time we press space.

The rest of these just run the clock at various speeds from
once a second when you press one, all the way up to once a
millisecond (or really just as fast as it can go)
when you press 9, and then zero stops it completely.

So we're pretty much done with sandpaint,
but I did want to add a few more keys to demonstrate
why these things were invented.

* TODO 3. sandpaper
#+begin_src j

NB. (title card: sandpaper)

cocurrent 'sandpaint'
wd'psel ',(":gpw_hwnd),'; ptimer 0'
pen =: 4
#+end_src
** why sandpiles?

What's the point of these things?

Well, there's this whole class of phenomena in physics
where you're measuring something at regular intervals
maybe the water level of a river over time,
or the elevation along a mountain range,
or the amount of static in a radio transmission,
and your numbers seem to jump around randomly,
but it isn't completely random.





Critical configuration:
  earthquakes
  avalanches or landslides
  "self-organized criticality"

  small changes can cause huge effects
  mostly nothing happens, but every once in a while, you have an earthquake

stock prices
level of the nile river
errors in transmission signals
electronic vacuum tubes in 1925
human heart rates or brainwaves
decade = factor of 10



** TODO the sandpaper
#+begin_src j
cocurrent 'sandpaint'

copy =: img

gpw_char =: verb define
  time_keys''
  NB. "Self-organized criticality: an explanation of 1/f noise"
  NB. Per Bak, Chao Tang, and Kurt Wiesenfeld
  select. {. sysdata
    case. 'r' do. render img =: 4 + ? 32 32 $ 4    NB. r = random grid
    case. 'R' do. render img =: 4 + ? 100 100 $ 4  NB. R = big random grid
    case. 'f' do. render img =: settle^:_ img      NB. f = fast forward
    case. 'c' do. copy =: img                      NB. c = copy
    case. 'x' do. render 'img copy' =: copy;img    NB. x = swap
    case. '?' do. viewmat copy ~: img              NB. ? = show diff
  end.
)
#+end_src

Sandpiles were introduced in a physics paper in 1987, this is what they did.

First, they generated a big random grid of sand where every cell had at least four grains.

Then they let it run. I'm doing this at two frames a second so it doesn't start strobing and give someone a seizure,
but even running at full speed, this takes quite a while to animate.

So the f key uses the power conjunction to let us fast forward to the end, which happens pretty much instantly.

Now once we've got it settled, we're going to store a copy of the image.

Now I'm going to turn the speed back up, and add one grain of sand, by clicking on a cell at random and turning it into a four.

We can do that a few times, and we notice that sometimes we have a big change and sometimes we have a small change.

** sandpaper demo
#+begin_src j
Note 'sandpaper setup'
  - full screen term window
  - 'desktop only' in obs
  - session font to consolas/24
)
open'~JTalks/s1/e2-sandpiles/sandpaper.ijs'
#+end_src


As far as I could tell, though, they were trying to model the idea that certain systems
tend to naturally settle into a critical point that's just barely stable,
where a slight disturbance triggers a huge change -
something like an avalanches and earthquakes.

So for their work, they generated big grids full of random big numbers,
letting everything settle, and then studied how far the cascade extended when
they set a single cell to four.
 
* TODO 4. sandcalc
#+begin_src j

NB. (title card: sandcalc)

#+end_src
** TODO sandcalc
Since then, sandpiles have caught the attention of mathematicians.
In fact, I first heard about them on a numberphile video
(which I've linked in the description)
that explains how for any size grid
(or even arbitrary connected graph)
there's a subset of sandpile configurations
that form a group under addition with settling.

** TODO sandcalc - window
#+begin_src j
cocurrent 'sandcalc'
coinsert 'sandpiles gridpad'

gpo_title =: 'sandcalc - sandpile calculator'
gpo_timer =: 200
gpo_statusbar =: 0
gpo_colorpick =: 0
gpo_menu =: ''

gpw_init_controls =: verb define
  wd'bin h'
  wd' minwh  50 200; cc palv isigraph;'
  wd' minwh 200 200; cc sp0v isidraw;'
  wd' cc "+" static;'
  wd' minwh 200 200; cc sp1v isidraw;'
  wd' cc "+" static;'
  wd' minwh 200 200; cc sp2v isidraw;'
  wd' cc "=" static;'
  wd' minwh 200 200; cc sp3v isidraw;'
  wd'bin z'
)

render =: ]  NB. because there's no 'imgv' control

gpw_init''

#+end_src

So to show what that means, here's a little calculator.
Basically, you can add this all-zero sandpile to any sandpile,
and it acts just like adding zero to an integer.

** TODO sandcalc - render
#+begin_src j
cocurrent 'sandcalc'

pal =: i.4                      NB. limit to stable piles
pen =: 0                        NB. color to draw with

NxN =: 5 5
sp0 =: NxN $ 0
sp1 =: NxN $ 3
sp2 =: NxN $ 0

(update =: verb define)''
  sp3 =: settle^:_ sp0 + sp1 + sp2
)

render =: verb define
  vmcc sp0;'sp0v'
  vmcc sp1;'sp1v'
  vmcc sp2;'sp2v'
  vmcc sp3;'sp3v'
)

#+end_src

** TODO sandcalc - mouse
#+begin_src j
cocurrent 'sandcalc'

gpw_sp0v_mwheel =: gpw_sp1v_mwheel=: gpw_sp2v_mwheel=: gpw_palv_mwheel

NB. left click draws on the input
gpw_sp0v_mblup =: verb : 'sp0 =: sp0 img_draw whichbox 40'
gpw_sp1v_mblup =: verb : 'sp1 =: sp1 img_draw whichbox 40'
gpw_sp2v_mblup =: verb : 'sp2 =: sp2 img_draw whichbox 40'

NB. left drag does the same
gpw_sp0v_mmove =: verb : 'if. mbl _ do. gpw_sp0v_mblup _ end.'
gpw_sp1v_mmove =: verb : 'if. mbl _ do. gpw_sp1v_mblup _ end.'
gpw_sp2v_mmove =: verb : 'if. mbl _ do. gpw_sp2v_mblup _ end.'

NB. right click to copy the sum to an input
gpw_sp0v_mbrup =: verb : 'sp0 =: sp3'
gpw_sp1v_mbrup =: verb : 'sp1 =: sp3'
gpw_sp2v_mbrup =: verb : 'sp2 =: sp3'

NB. middle click to reset the input
gpw_sp0v_mbmup =: verb : 'sp0 =: NxN$0'
gpw_sp1v_mbmup =: verb : 'sp1 =: NxN$3'
gpw_sp2v_mbmup =: verb : 'sp2 =: ZSP'

ZSP =: NxN $ 0 NB. the trivial zero
#+end_src

** TODO the zero sandpile : construction

Make a 5x5 sandpile of all 4s

settle it.

clean up border

reverse it

** TODO the zero sandpile in j

#+begin_src j
cocurrent 'sandcalc'

stl =: settle^:_
ZSP =: stl (4 - stl) NxN $ 4
sp2 =: ZSP

#+end_src


But you can never add any two other sandpiles together
to get this one, because you'd always leave some sand on the table.

But it turns out that for any size grid you can come up with,
there's always a subset of configurations for which you can define
a second zero, and for any sandpile in this subset, there's always
an inverse sandpile that brings it back to zero.

So this number in the middle is the group zero, and
according to this calculator, adding it to the grid of all
threes produces the grid of all threes.

If I understood everything correctly, then you can test whether
a particular configuration is in the group just by adding this
middle zero to it. If it comes out the same, then it ought
to have an inverse.

So for example, this grid of all threes has an inverse,
but any time you put two zeros next to each other,
you get something different. Same thing with any square of ones.
There's nothing you can add to this to get back to zero.

Well, okay, but how do we actually know this block of solid threes has an inverse?
I suspect there's an algorithm that comes up with it, and that people who have
studied this already know what it is. But I don't know what it is.

However, I do know what the inverse of this sandpile is, because I found it:

** TODO inverse of all threes
#+begin_src j
cocurrent 'sandcalc'

sp0 =: ".;._2 noun define
  3 1 3 1 3
  1 3 2 3 1
  3 2 1 2 3
  1 3 2 3 1
  3 1 3 1 3
)

NB. there are actually at least two

sp0 =: 5 5 $ 1 1 3 1 1 1 1 1 1 1 3 1 1 1 3 1 1 1 1 1 1 1 3 1 1
sp0 =: 5 5 $ 3 1 3 1 3 1 3 2 3 1 3 2 1 2 3 1 3 2 3 1 3 1 3 1 3

wd'psel ',":gpw_hwnd
wd'ptop'
#+end_src

It's actually kind of an interesting puzzle to find a group item and then try to figure out the inverse.

* TODO _. outro
* TODO Video Description and Links

Code for this episode:
https://github.com/tangentstorm/j-talks/tree/master/s1/e2-sandpiles

Numberphile video on sandpiles with Dr Luis David Garcia-Puente:
https://www.youtube.com/watch?v=1MtEUErz7Gg

Professor David Perkinson has a textbook on sandpile math, as well as interactive software:
http://people.reed.edu/~davidp/

Original sandpile paper:
http://cqb.pku.edu.cn/tanglab/pdf/1987-63.pdf

Sandpile math paper, including the algorithm to generate the "zero":
https://hal.archives-ouvertes.fr/hal-00016378

WikiZero on sandpiles:
https://www.wikizero.com/en/Sandpile

Code golf challenge with sandpiles in various languages:
https://codegolf.stackexchange.com/questions/92251/build-a-sandpile

J Vocabulary:
https://code.jsoftware.com/wiki/NuVoc

Download J from:
https://code.jsoftware.com/wiki/Guides/Getting_Started
