This series is about
building interactive applications
in the J programming language.

In this episode, we'll start out very simple
with some basic livecoding.

Livecoding just means
that we change the code for our program
as its running,
without having to stop and restart it
each time we make a change.

So on the screen here,
I have two J windows open.
Down here is the J terminal.
On the right is the integrated editor.
I happen to be running running version j807
but pretty much any version from the past
couple years should work.

So for this video, we're going to do some animation.

We're going build a window
that draws an image to the screen every few milliseconds,
and we're going to provide some controls
for changing how its drawn.
But for now,
rather than drawing menus
and toolbars
and whatnot in our GUI,
we'll control the animation
by executing lines of J.

Obviously,
this is not the way to build a
shippable application for other people to use
but it's a decent technique for demonstrations
and rapid prototyping
and it will give us a start
on the techniques we need
to build more advanced user interfaces later.

Okay so the firs thing we'll do is load viewmat.            load 'viewmat'
I typed it into the editor window.
I press control enter.
And it runs in the terminal.

If you try this and get an error,
you probably just need to install viewmat.
To fix that, go to tools/package manager
from either one of these windows.
Then select graphics/viewmat
from this list of packages,
and hit install.
Or do what I do and select everything.
The entire collection is only about 53 megabytes.

Once you get this line to run,
we can test that viewmat works
by telling it to render a 10 by 10 grid.                     viewmat i. 10 10


Notice that if we run this line again
we get another window.

But for animation
we want to be able to
re-use the same window over and over again.
so let's make that happen.

#+begin_src j
wd 'pc w0 closeok'                  NB. parent control (window) named 'w0'
wd 'minwh 500 500; cc g0 isidraw;'  NB. add an 'isidraw' child control named 'g0'
wd 'pshow'                          NB. show it window.
#+end_src

These three lines are what you need to build a GUI in J.
=wd= stands for window driver.
It's a verb that interprets
a mini language for building GUIs.
It used to be a wrapper for the windows API
and now that J is open source and cross platform,
it's talking to a library called Qt under the hood.

The first line defines a parent control named w0.
Parent control is just their term for window.

The second line creates a 500 by 500 pixel
child component called g0.
It's an isidraw, which is a sort of canvas
component specific to J.

I believe ISI stands for Iverson Software Incorporated.
It was just the company name before it became jsoftware.

The last line shows the window.
Control-enter, and here it is.

Just for the purpose of the video, I'm going to change that last line.

#+begin_src j
wd 'pshow; pmove 40 510 0 0'        NB. show the window at the given coordinates.
#+end_src

=pmove= just moves and optionally resizes the parent control.

We'll get our feedback from the window itself
so we don't really need the terminal
unless there's a bug.

But just as another example of how we're going to control
this interface through code,
let's paste in two more lines:

#+begin_src j
wd 'sm focus term'                  NB. session manager: bring terminal to front
wd 'psel w0; ptop'                  NB. bring our window to front
#+end_src

The first line tells the j session manager
to activate the terminal.

So now the keyboard focus is in the terminal.

If I alt tab, I'm back in the editor
and I can run this second line to bring my
parent control back to the top.


We have two more bits of setup.

First, we want to get viewmat running in that window.

There might be a better way to do this, but so far, what I use is this:
#+begin_src j
vmcc =: glpaint_jgl2_@viewmatcc_jviewmat_   NB. viewmat to a child control
#+end_src

I wish I didn't need this line.
It's something internal to viewmat
that used to be exposed by default.
All it does is run viewmat
and send the output to a child control.

It looks like this:


#+begin_src j
[ im =: ? 10 10 $ 100
vmcc im;'g0'
#+end_src

So this line just generates a 10 by 10
grid of integers between 0 and 99.

We're assigning it to a variable named im.
The left bracket dumps it to the terminal
just so you can see it.

The next line renders it to our canvas, g0.
And if we run these two lines again, then
we get a new random matrix and the image
gets rendered in place.

And if we kept doing that on a timer,
that gives us our animation system.


So first we'll move these two lines
into a verb called =step=.

#+begin_src j
step =: verb define
  im =: ? 10 10 $ 10
  vmcc im;'g0'
)
#+end_src

To run this, you put the cursor on the end of the first line.
and press control return
and it runs the whole definition.

This verb ignores its arguments,
so we can just pass it anything, and run it like this:
#+begin_src j
step''
#+end_src
Every time we run it, we get a new random matrix
and it gets drawn to the screen.

Next we need to define a verb called =sys_timer= in the z locale,
and it's just going to be an alias for =step=.
#+begin_src j
sys_timer_z_ =: step_base_
#+end_src

I don't want to get too deep into locales right now.
They're very similar to objects in javascript.
They're just namespaces, but they're chained together,
so when you look a name up,
you look at each locale in
the chain until you find it.

The =z= locale is special, in that every chain always ends with =z=.
By putting something in the =z= locale you're effectively making it global.

The syntax is a little backwards from what you'd see in object orient programming.
I like to think of these trailing underscores as like the subscripts they use in math.
So where in most languages you might say this as =z.sys_timer=,
in J you say, =sys_timer_z_=.

The word =base= is also a locale. It's not special,
except that it's the default namespace that you get when you start j.

We have to write it here because z is the end of the chain, so it can't
see anything outside of z, unless we give it an explicit namespace.


So now that we've done this, we can invoke our local =step= verb
as the global verb =sys_timer=:

#+begin_src j
sys_timer''
#+end_src

What was the point of that?

Well, the window driver has a timer capability,
and it explicitly calls =sys_timer_z_=.

We could have just defined our step verb as =sys_timer_z_= to begin with, but I just prefer this style.

Anyway, you start the timer like this:

#+begin_src j
wd 'timer 100'
#+end_src

The number says how many milliseconds to wait between frames.
Setting it to 0 turns it off.

Okay, so now we've got our animation system.

Now in the next couple videos
we're going to do some animations that are more interesting that random noise.

So let's make a small refactoring,
and split these into separate functions.


#+begin_src j
update =: verb define
  im =: ? 10 10 $ 100
)

render =: verb define
  vmcc im;'g0'
)

step =: render @ update
#+end_src

And then for now, let's move this line out of =update=.

#+begin_src j
im =: ? 10 10 $ 100   NB. initialize to a random array

update =: verb define
  '' NB. do nothing for now
)
#+end_src

The animation is still running, but =im= isn't changing.
Whenever we use this setcolon operator, we're making the
assignment in the current locale. So if you were expecting
=im= to be a local variable inside this verb, it's not. It's
more like a member variable of an object, where the object
is the current locale.

But if we were to run this script in a fresh copy of j
without initializing =im=, that would cause an error.


So the promise was that we'd provide some way to control all this with code.
Here's what I had in mind:

#+begin_src j
NB. some nice arrays to look at.
im =: ? 10 10 $ 2            NB. random black/white pattern
im =: ? 100 100 $ 2          NB. higher resolution
im =: i. 10 10               NB. count to 100
im =: |: i. 10 10            NB. same thing, transposed
im =: i. 2 2                 NB. a simple 4-square
im =: j./~ i:10              NB. the complex plane, near the origin
im =: |j./~ i:10             NB. magnitudes from the center
im =: 10 10 $ 1              NB. pure white
im =: 1 (<5 5) } 11 11 $ 0   NB. one white pixel in the middle
im =: ~:/\^:(<@#) 8 # 1      NB. mysterious triangle??
#+end_src

These are just a bunch of lines I came up with.



#+begin_src j
NB. operators on the current pattern:
im =: im * i.$im             NB. rainbowfy a black and white image
im =: 2 | im                 NB. reduce color to black and white (using mod 2)
im =: |: im                  NB. transpose
im =: |. im                  NB. flip top to bottom
im =: |."1 im                NB. flip left to right
im =: |: |. im               NB. rotate 90 degrees
im =: |. |: im               NB. rotate the other way
im =: -. im                  NB. flip the bits
im =: ,~ ,.~ im              NB. split into four copies
im =: (,|.) (,. |."1) im     NB. four copies, but mirrored across each axis
im =:  1 |. im               NB. rotate up (top row moves to bottom)
im =: _1 |. im               NB. rotate down
im =:  1 |."1 im             NB. rotate left
im =: _1 |."1 im             NB. rotate right
im =: }. im , 0              NB. shift up, pad with 0
im =: 0 , }: im              NB. shift down, pad with 0
im =: }."1 im ,. 0           NB. shift left, pad with 0
im =: 0 ,. }:"1 im           NB. shift right, pad with 0
#+end_src


you can experiment with running these lines interactively with ctrl-enter,
or ctrl-r which runs the line without advancing the cursor (so you can run it over and over again)

before i end, i should point out that while I was typing these, i'd occasionally
screw something up and set im to something that wasn't a 2d matrix.
This caused a modal error message to pop up on every frame, so that
and so every time I closed the message it popped right back up.

The only way to recover was to kill J, which was really annoying.
So to fix that, I added some trapping for this in the render verb:

#+begin_src j
render =: verb define
  if. 2 = #$ im            NB. only render if im is a 2d array
  do. vmcc im;'g0' end.    NB. (this avoids infinite error boxes)
)
#+end_src

Finally, here are a couple different takes on the update function:

#+begin_src j
NB. some update strategies:
update =: verb def 'im =: 10 | im + 1'   NB. rotate the palette
update =: ]                              NB. do nothing
#+end_src

Anyway, my hope is that some of you actually download and experiment with this code.
You can also post questions to the jsoftware forums or the IRC channel.

I intend this to be the first in a series of videos about interactive j.
The next couple videos are going to build on this initial framework
to do some more interesting things.

