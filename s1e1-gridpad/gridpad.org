#+title: gridpad
#+property: header-args:j  :tangle "gridpad.ijs" :noweb tangle
: (require 'ox-org)   <- eval this line to export tangled org with C-c C-e O o (org-org-export-to-org)

* window setup
#+begin_src j
gpw_close =: verb define                  NB. when 'gpw' close button clicked
  wd'psel gpw; pclose; timer 0'
)

gpw_close^:(wdisparent'gpw')''            NB. close old window each time we run.

wd 'pc gpw closebutton; minwh 640 500'    NB. create window 'gpw'
wd 'pn "gridpad: simple sprite editor"'   NB. add title
wd 'bin v'                                NB. vertical bin
wd '  bin h'                              NB.   horizontal bin
wd '    cc pal isigraph;setwh pal 25 400' NB.     narrow isigraph for palette
wd '    set pal sizepolicy fixed fixed'   NB.     keep palette from resizing
wd '    cc img isidraw;setwh img 480 480' NB.     square isigraph for drawing
wd '  bin z'                              NB.   /bin
wd '  cc sb statusbar'                    NB.   status bar
wd '  set sb addlabel text'               NB.   ... with status text
wd 'bin z'                                NB. /bin
wd 'pmove 40 490 0 0; ptop; pshow'        NB. position and show window.
#+end_src

Top part is housekeeping for development, so you can run the script many times.

Bottom part lays out the window.

Bins allow you to layout controls.

* viewmat in child control
#+begin_src j
require 'viewmat'
coinsert 'jviewmat jgl2'

vmcc =: verb define                       NB. invoke viewmat in a child control
  'pc cc img' =. y                        NB. usage: vmcc(parent;child;pixels)
  wd 'psel ',pc                           NB. select parent control
  glpaint [ 'rgb' vmcc_jviewmat_ img;cc   NB. blit the pixel data and repaint.
)
#+end_src

Now we import viewmat and define vmcc.

I covered this idea in the animation video.

In that video
we just called this vmcc from jviewmat
and then called glpaint.

This time, I also pass in the parent control name,
so we can select the window we're working with.

If you only ever have one window
you don't need the psel step but it's probably good practice.

In my case, this presentation window
is also running in J.

Maybe I'll talk about that in another video someday.

But for now, let's call our function.

* render "animation"
#+begin_src j
image =: 32 32 $ 0

render =: verb define
  vmcc 'gpw';'img';image
)

NB. call 'render' 10 times a second.
step =: render
sys_timer_z_ =: step_base_
wd 'timer 100'
#+end_src

This is a bit wasteful since we're not really animating here, but it's handy for development.
The alternative is to explicitly call render each time we make a change.

* draw a grid
#+begin_src j
showgrid =: 1

render =: verb define
  vmcc 'gpw';'img';image
  if. showgrid do.
    'vw vh' =. glqwh glsel'img' [ 'ih iw' =. $ image
    glpen glrgb 255 255 255
    gllines <. 0.5+ (0, ], vw, ])"0 (vh%ih) * i.ih
    gllines <. 0.5+ (], 0, vh,~])"0 (vw%iw) * i.iw
  end.
)
#+end_src
The shape of the grid gives us its height and width.
And this means query width and height of the viewport.

If we divide the viewport into this many chunks we get the cell size,
and if we multiply that by this range, we get the y coordinate for each horizontal line.
So then this part maps each y coordinate to the start and end coordinates,
and gllines draws the whole array.
Same thing for the vertical lines.

* keyboard shortcuts
#+begin_src j
NB. keyboard events are widget-specific, but we want same for img/pal
gpw_pal_char =: gpw_img_char =: verb define
  select. {. sysdata
    case. '0' do. image =: 32 32 $ 0
    case. 'r' do. image =: ? 32 32 $ 2^24
    case. 'g' do. showgrid =: -. showgrid
  end.
)
#+end_src

* mouse coordinates
Let's show the mouse coordinates.
#+begin_src j
gpw_img_mmove =: verb define
  wd 'set sb setlabel text *', ":sysdata
)

#+end_src
* grid coordinates

#+begin_src j
gpw_img_mmove =: verb define
  wd 'set sb setlabel text *', ": whichbox cellsize''
)

whichbox =: verb define                   NB. which cell is the mouse over?
  |. <. y %~ 2 {. ".sysdata               NB. (only works inside mouse events)
)

cellsize =: verb define
  (glqwh glsel'img') % |.$ image
)
#+end_src
* click to draw

Now, when we click the sandpile widget, the same calculation needs to happen.

#+begin_src j
gpw_img_mblup =: verb define
  NB. left click to draw on the image
  mousedraw whichbox cellsize''
)

mousedraw =: verb define
  NB. y is the (y,x) coordinates of the pixel to draw
  image =: 16bffffff (< y) } image
)
#+end_src

For the palette, the box size was fixed, but for the sandpile,
we can change the size of the grid, so we have to figure it out dynamically.
And of course, it's the same calculation as before, where
we query the width and height of the canvas and divide by the shape of the grid
with this reverse in the middle because shape gives height and width instead
of width and height.

Now mousedraw takes the grid on the left (so that's x)
and the box size on the right. (That's y).
The box size goes into whichbox,
which looks at sysdata
and gives back the y x grid coordinates of the mouse.

This part in the middle clamps those coordinates so they're between zero zero (which is upper left)
and the lower right corner, which is one less than the height and width of the grid.
This is completely un-necessary for clicking because this =mblup= only fires when you're actually inside the grid.
But we're going to use this routine again later for dragging
and if you drag off the side it sometimes fires the event even when you're out of bounds.

Okay so now we have the clamped grid coordinates, and this less than sign puts them in a box.
Now this whole line says to take the number corresponding to the current pen,
and put it into a copy of the grid at the coordinates we calculated.
* bounds checking

#+begin_src j
inbounds =: dyad define
  *./ (x >: 0) *. x < y
)

mousedraw =: verb define
  NB. y is the (y,x) coordinates of the pixel to draw
  if. y inbounds $image do.
    image =: 16bffffff (< y) } image
  end.
)
#+end_src

* drag to draw

And of course it would be much nicer if we could draw continously by holding the left button down and moving the mouse.

So that looks like this:

#+begin_src j
lmb =: verb : '4 { ".sysdata'             NB. left mouse button

gpw_img_mmove =: verb define
  wd 'set sb setlabel text *', ": whichbox cellsize''
  if. lmb'' do. gpw_img_mblup'' end.
)
#+end_src

When the mouse moves over the canvas in the image control,
if button zero is down then just call the click method.

Anyway, now we can draw continuously.

* the palette

#+begin_src j
NB. default palette (16-color vga text colors)
pal =:      16b000000 16baa0000 16b00aa00 16baa5500
pal =: pal, 16b0000aa 16baa00aa 16b00aaaa 16baaaaaa
pal =: pal, 16b555555 16bff5555 16b55ff55 16bffff55
pal =: pal, 16b5555ff 16bff55ff 16b55ffff 16bffffff

gpw_pal_paint =: verb define
  vmcc 'gpw';'pal';,.pal           NB. ,. makes pal a 2d array
)
#+end_src

Normally viewmat takes the min and max numbers in the matrix you're viewing
and maps the palette evenly across that range. But that doesn't work so well
when you have a mix of really small numbers like zero through four,
and then really big numbers like 2^16.

I'm still using a palette, but I map the numbers on the grid to the numbers in the
palette up front, and then tell viewmat to just render the numbers as RGB color values
by passing in the string 'rgb' as the left parameter.

I will point out that the the current drawing color
is stored in a member variable called pen. It's just
a number betwen 0 and 19 corresponding to an index
in the pal and num arrays.

You should be able to select a color either by clicking on it,
or by turning the mouse wheel. And you should be able to turn
the wheel even while you're drawing.

* pen color
#+begin_src j
pen =: <: # pal  NB. start with last color (white)

pal_cellsize =: (glqwh glsel 'pal') % 1,#pal

gpw_pal_mblup =: verb define
  NB. left click palette to set pen color
  glpaint glsel 'pal' [ pen =: {. whichbox pal_cellsize
)
#+end_src

* draw with the pen
#+begin_src j
mousedraw =: verb define
  NB. y is the (y,x) coordinates of the pixel to draw
  if. y inbounds $image do.
    image =: (pen { pal) (< y) } image
  end.
)
#+end_src

* show current color
#+begin_src j
gpw_pal_paint =: verb define
  vmcc 'gpw';'pal';,.pal           NB. ,. makes pal a 2d array
  NB. draw a box around the current pen color:
  glbrush glrgba 0 0 0 0  [ h =. {: cellsize =. pal_cellsize
  glrect 3, (3+pen*h), _5 _5 + cellsize [ glpen 5 [ glrgb 0 0 0
  glrect 3, (3+pen*h), _5 _5 + cellsize [ glpen 1 [ glrgb 3 $ 255

  NB. black box around everything:
  glrect 0 0, (glqwh 'pal') [ glpen 1 [ glrgb 0 0 0
)
#+end_src

* mouse wheel

#+begin_src j
NB. mouse wheel on either control rotates through palette
gpw_img_mwheel =: gpw_pal_mwheel =: verb define
  pen =: (#pal)|pen-*{:".sysdata NB. sign of last item is wheel dir
  glpaint glsel'pal'
)
#+end_src

Event handlers are just verbs, and they follow this naming convention of
parent name, child name, event name. So here I'm just giving two names to
the same verb, and they start working immediately.

Now the way mouse events work is that the coordinates get stuck in this string called sysdata.
Let's have it print each time I scroll the mouse wheel.

For every mouse event on an isigraph, sysdata is going to be a string with the position of the mouse cursor,
the width and height of the viewport, a set of bits representing which of the first three buttons were down,
two bits for whether shift or control were pressed,
and the mouse wheel rotation in degrees.
(These two bits are always zero)

So here we just convert that string to an array, take the last item.
For my mouse that seems to always be either fifteen or negative fifteen, but probably it changes with different hardware.
Anyway, we don't care about the number, just the direction, so asterisk takes the sign of that, giving us -1, 0, or 1.
We add that to our pen variable, and then take that modulo the length of the palette so it wraps around.

Then we just tell the palette control to repaint, which triggers a paint event, which calls =spw_pal_paint=.

Now to handle clicking we make another event handler -- =mblup= means mouse button left up.

But this time we want to pay attention to the first two numbers to figure out which box got clicked on.
We divide by the size of the boxes, (which I passed in here) round down and then reverse because
the mouse coordinates are x y but for an array the y coordinate comes first.

So that gives us the y and x coordinates of the box in the grid, but we only have one column so we only need the y.
So we use the behead operator and that's our new pen, and again we tell the palette to repaint itself.

* file menu
#+begin_src j
wd 'psel gpw'
wd 'menupop "&File"'                      NB. File menu
wd '  menu new  "&New"  "Ctrl+N"'
wd '  menu open "&Open" "Ctrl+O"'
wd '  menu save "&Save" "Ctrl+S"'
wd 'menupopz'
#+end_src

* file /new new item
#+begin_src j
gpw_new_button =: verb define
  image =: 0 * image                      NB. set to black
)
#+end_src

* load / save
#+begin_src j
require 'png'

gpw_open_button =: verb define
  path =. wd 'mb open1 "Load a png file" filename "PNG (*.png)"'
  if. #path do. image =: readpng path end.
)

gpw_save_button =: verb define
  path =. wd 'mb save "Save image" filename "PNG (*.png)"'
  if. #path do. image writepng path end.
)
#+end_src

* custom colors
#+begin_src j
gpw_pal_mbrup =: verb define
  pen =: {. whichbox {: pal_cellsize      NB. same as mblup: set pen
  rgb =: ": 256 256 256 #: pen { pal      NB. get 'r g b' string for old color
  if. #rgb =. wd'mb color ',rgb do.       NB. show system color picker
    c =. 256 #:^:_1 ".rgb                 NB. turn new 'r g b' into new
    pal =: c pen } pal                    NB. update the palette...
  end.
  glpaint glsel 'pal'                     NB. ... and redraw it.
)
#+end_src
* the end
#+begin_src j




 thanks for watching!

#+end_src
